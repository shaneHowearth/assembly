package main

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	money "github.com/Rhymond/go-money"
)

var (
	testUsers []*User
	testBooks []*Book
)

func TestMain(m *testing.M) {

	testUsers = []*User{
		&User{"TestUserA", money.New(10000, "AUD")},
		&User{"TestUserB", money.New(10000, "AUD")},
	}
	testBooks = []*Book{

		&Book{title: "TestBook", forSale: true, price: money.New(1000, "AUD"), owner: testUsers[0]},
		&Book{title: "TestBookB", forSale: true, price: money.New(1000, "AUD"), owner: testUsers[1]},
		&Book{title: "Not For Sale", forSale: false, price: money.New(1000, "AUD"), owner: testUsers[1]},
	}
	m.Run()
}

func testReset() {
	// Reset user's money
	testUsers[0].bankBal = money.New(10000, "AUD")
	testUsers[1].bankBal = money.New(10000, "AUD")

	// Reset book state
	testBooks[0].owner = testUsers[0]
	testBooks[0].forSale = true

	// Clear all transactions generated by tests
	transactions = transactions[:0]
}

//
func ExampleHelp() {
	Help()
	// Output: Available commands:
	//    Help - Prints this message.
	//    Bal - Gets the current bank balances.
	//        If a name is given then only the bank balance for that person.
	//    Books - List all the books for sale, or all of the books owned by the given name.
	//    Transactions - Get all of the transactions that have occurred.
	//    Exit - Exits this program.
}

// TestGetBankBalance -
func TestGetBankBalance(t *testing.T) {
	testcases := map[string]struct {
		username string
		response string
		err      error
	}{
		"TestUserA": {
			username: "TestUserA",
			response: "100\n",
		},
		"TeSTusEra (incorrect case)": {
			username: "TeSTusEra",
			response: "100\n",
		},
		"Doesn't exist": {
			username: "Doesn't exist",
			err:      fmt.Errorf("Not found"),
		},
		"Empty": {
			response: "Bob - 100\nKelly - 100\n",
		},
	}
	for name, tc := range testcases {
		resp, e := GetBankBalance(tc.username, testUsers)
		if tc.err != nil {
			assert.Errorf(t, tc.err, e.Error(), "%s returned and incorrect error", name)
		}
		assert.Equalf(t, tc.response, resp, "%s response was incorrect", name)
	}

}

func TestGetBookList(t *testing.T) {
	testcases := map[string]struct {
		username string
		response string
	}{
		"Successful search": {
			username: "TestUserA",
			response: "TestBook\n",
		},
		"Successful search with Not for sale book": {
			username: "TestUserb",
			response: "TestBookB\nNot For Sale\n",
		},
		"No username provided": {
			response: "TestBook\nTestBookB\n",
		},
		"Random case": {
			username: "TeSTuSeRA",
			response: "TestBook\n",
		},
		"Non Existant": {
			username: "Non-existant",
			response: "User not found",
		},
		"Leading and Trailing whitespace": {
			username: " TestUserA ",
			response: "TestBook\n",
		},
		"Unicode": {
			username: "Testing «ταБЬℓσ»: 1<2 & 4+1>3, now 20% off!",
			response: "User not found",
		},
	}
	testReset()
	for name, tc := range testcases {
		bookString := GetBookList(tc.username, testBooks, testUsers)
		assert.Equal(t, tc.response, bookString, "%s provided an incorrect book string", name)
	}
}

func TestGetTransactions(t *testing.T) {
	testcases := map[string]struct {
		testbook *Book
		first    *User
		second   *User
		amount1  string
		amount2  string
		tType1   string
		tType2   string
		expected bool
	}{
		"Successful bid": {
			testbook: testBooks[0],
			first:    testUsers[0],
			second:   testUsers[1],
			amount1:  "10.00",
			amount2:  "TestBook",
			tType1:   "paid",
			tType2:   "sold",
			expected: true,
		},
		"Unsuccessful bid": {
			testbook: testBooks[0],
			first:    testUsers[0],
			second:   testUsers[1],
			amount1:  "1.00",
			expected: false,
		},
	}
	for name, tc := range testcases {
		testReset()
		// create a tranasaction
		arguments := fmt.Sprintf("%s, %s, %s", tc.second.name, tc.testbook.title, tc.amount1)
		_ = Bid(arguments, testBooks, testUsers)
		// GetTransactions returns a string.
		// However the tests will check the transactions objects directly
		_ = GetTransactions()
		if tc.expected {
			assert.NotEmptyf(t, transactions, "%s has produced no transactions", name)
			assert.Equal(t, tc.second.name, transactions[0].first.name, "%s has the wrong user first in the first entry", name)
			assert.Equal(t, tc.first.name, transactions[0].second.name, "%s has the wrong user second in the first entry", name)
			assert.Equal(t, tc.amount1, transactions[0].value, "%s has the wrong value in the first entry", name)
			assert.Equal(t, tc.tType1, transactions[0].tType, "%s has the wrong transaction type in the first entry", name)
			assert.Equal(t, tc.first.name, transactions[1].first.name, "%s has the wrong user first in the second entry", name)
			assert.Equal(t, tc.second.name, transactions[1].second.name, "%s has the wrong user second in the second entry", name)
			assert.Equal(t, tc.amount2, transactions[1].value, "%s has the wrong value in the second entry", name)
			assert.Equal(t, tc.tType2, transactions[1].tType, "%s has the wrong transaction type in the second entry", name)
		} else {
			assert.Emptyf(t, transactions, "%s has produced transactions when none were expected", name)

		}
	}
}
