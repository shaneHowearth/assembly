package main

import (
    "errors"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	money "github.com/Rhymond/go-money"
)

var (
	testUsers []*User
	testBooks []*Book
)

func TestMain(m *testing.M) {

	testUsers = []*User{
		&User{"TestUserA", money.New(10000, "AUD")},
		&User{"TestUserB", money.New(10000, "AUD")},
	}
	testBooks = []*Book{

		&Book{title: "TestBook", forSale: true, price: money.New(1000, "AUD"), owner: testUsers[0]},
		&Book{title: "TestBookB", forSale: true, price: money.New(1000, "AUD"), owner: testUsers[1]},
		&Book{title: "Not For Sale", forSale: false, price: money.New(1000, "AUD"), owner: testUsers[1]},
	}
	m.Run()
}

func testReset() {
	// Reset user's money
	testUsers[0].bankBal = money.New(10000, "AUD")
	testUsers[1].bankBal = money.New(10000, "AUD")

	// Reset book state
	testBooks[0].owner = testUsers[0]
	testBooks[0].forSale = true

	// Clear all transactions generated by tests
	transactions = transactions[:0]
}

//
func ExampleHelp() {
	Help()
	// Output: Available commands:
	//    Help - Prints this message.
	//    Bal - Gets the current bank balances.
	//        If a name is given then only the bank balance for that person.
	//    Bid - Bid for a book.
	//        Give the name of the person bidding, the name of the book they are bidding for, and the amount that they are bidding. If successful the book will change ownership, and the money paid from the bidder's wallet to the seller's.
	//    Books - List all the books for sale, or all of the books owned by the given name.
	//    Transactions - Get all of the transactions that have occurred.
	//    Exit - Exits this program.
}

// TestGetBankBalance -
func TestGetBankBalance(t *testing.T) {
	testcases := map[string]struct {
		username string
		response string
		err      error
	}{
		"TestUserA": {
			username: "TestUserA",
			response: "100\n",
		},
		"TeSTusEra (incorrect case)": {
			username: "TeSTusEra",
			response: "100\n",
		},
		"Doesn't exist": {
			username: "Doesn't exist",
			err:      fmt.Errorf("Not found"),
		},
		"Empty": {
			response: "Bob - 100\nKelly - 100\n",
		},
	}
	for name, tc := range testcases {
		resp, e := GetBankBalance(tc.username, testUsers)
		if tc.err != nil {
			assert.Errorf(t, tc.err, e.Error(), "%s returned and incorrect error", name)
		}
		assert.Equalf(t, tc.response, resp, "%s response was incorrect", name)
	}

}

func TestBid(t *testing.T) {

	testcases := map[string]struct {
		seller      *User
		buyer       *User
		owner       *User
		book        *Book
		arguments   string
		buyerBal    *money.Money
		sellerBal   *money.Money
		status      bool
		expectedErr error
	}{
		"Successful Bid": {
			seller:    testUsers[0],
			buyer:     testUsers[1],
			owner:     testUsers[1],
			book:      testBooks[0],
			arguments: "TestUserB, TestBook, 10",
			buyerBal:  money.New(9000, "AUD"),
			sellerBal: money.New(11000, "AUD"),
			status:    false,
		},
		"Bid too low": {
			seller:    testUsers[0],
			owner:     testUsers[0],
			buyer:     testUsers[1],
			book:      testBooks[0],
			status:    true,
			buyerBal:  money.New(10000, "AUD"),
			sellerBal: money.New(10000, "AUD"),
			arguments: "TestUserB, TestBook, 7",
		},
		"Insufficient funds for bid": {
			seller:      testUsers[0],
			owner:       testUsers[0],
			buyer:       testUsers[1],
			book:        testBooks[0],
			status:      true,
			buyerBal:    money.New(10000, "AUD"),
			sellerBal:   money.New(10000, "AUD"),
			arguments:   "TestUserB, TestBook, 100000",
			expectedErr: errors.New("Sorry, you do not have enough available funds to make that bid"),
		},
		"Buyer is owner": {
			seller:      testUsers[0],
			owner:       testUsers[0],
			buyer:       testUsers[1],
			book:        testBooks[0],
			status:      true,
			buyerBal:    money.New(10000, "AUD"),
			sellerBal:   money.New(10000, "AUD"),
			arguments:   "TestUserA, TestBook, 7",
			expectedErr: errors.New("TestBook cannot be sold to TestUserA"),
		},
		"Book doesn't exist": {
			seller:      testUsers[0],
			owner:       testUsers[0],
			buyer:       testUsers[1],
			book:        testBooks[0],
			status:      true,
			buyerBal:    money.New(10000, "AUD"),
			sellerBal:   money.New(10000, "AUD"),
			arguments:   "TestUserA, TestBookXYZ is wrong, 7",
			expectedErr: errors.New("No book with that title found"),
		},
		"Missing an argument": {
			arguments:   "TestUserA TestBookXYZ is wrong, 7",
			expectedErr: errors.New("Usage: bid(username, bookname, bidAmount)"),
		},
		"Too many arguments": {
			arguments:   "TestUserA, TestBookXYZ is wrong, Extra, 7",
			expectedErr: errors.New("Usage: bid(username, bookname, bidAmount)"),
		},
	}
	for name, tc := range testcases {
		// reset the users and books
		testReset()
		// run test
		testErr := Bid(tc.arguments, testBooks, testUsers)
		if tc.expectedErr != nil {
			assert.Equalf(t, tc.expectedErr.Error(), testErr.Error(), "%s returned an incorrect error message", name)
		} else {
			assert.NoErrorf(t, testErr, "%s should not have an error but produced %v", name, testErr)
			// check balances
			// Seller
			assert.Equalf(t, tc.sellerBal.Amount(), tc.seller.bankBal.Amount(), "%s seller balance was incorrect", name)
			// Buyer
			assert.Equalf(t, tc.buyerBal.Amount(), tc.buyer.bankBal.Amount(), "%s buyer balance was incorrect", name)
			// check book ownership
			assert.Equal(t, tc.owner, tc.book.owner, "Book ownership wasn't updated for %s", name)
			// check book for sale status
			assert.Equal(t, tc.status, tc.book.forSale, "Book status wasn't updated for %s", name)
		}
	}
}

func TestGetBookList(t *testing.T) {
	testcases := map[string]struct {
		username string
		response string
	}{
		"Successful search": {
			username: "TestUserA",
			response: "TestBook\n",
		},
		"Successful search with Not for sale book": {
			username: "TestUserb",
			response: "TestBookB\nNot For Sale\n",
		},
		"No username provided": {
			response: "TestBook\nTestBookB\n",
		},
		"Random case": {
			username: "TeSTuSeRA",
			response: "TestBook\n",
		},
		"Non Existant": {
			username: "Non-existant",
			response: "User not found",
		},
		"Leading and Trailing whitespace": {
			username: " TestUserA ",
			response: "TestBook\n",
		},
		"Unicode": {
			username: "Testing «ταБЬℓσ»: 1<2 & 4+1>3, now 20% off!",
			response: "User not found",
		},
	}
	testReset()
	for name, tc := range testcases {
		bookString := GetBookList(tc.username, testBooks, testUsers)
		assert.Equal(t, tc.response, bookString, "%s provided an incorrect book string", name)
	}
}

func TestGetTransactions(t *testing.T) {
	testcases := map[string]struct {
		testbook *Book
		first    *User
		second   *User
		amount1  string
		amount2  string
		tType1   string
		tType2   string
		expected bool
	}{
		"Successful bid": {
			testbook: testBooks[0],
			first:    testUsers[0],
			second:   testUsers[1],
			amount1:  "10.00",
			amount2:  "TestBook",
			tType1:   "paid",
			tType2:   "sold",
			expected: true,
		},
		"Unsuccessful bid": {
			testbook: testBooks[0],
			first:    testUsers[0],
			second:   testUsers[1],
			amount1:  "1.00",
			expected: false,
		},
	}
	for name, tc := range testcases {
		testReset()
		// create a tranasaction
		arguments := fmt.Sprintf("%s, %s, %s", tc.second.name, tc.testbook.title, tc.amount1)
		_ = Bid(arguments, testBooks, testUsers)
		// GetTransactions returns a string.
		// However the tests will check the transactions objects directly
		_ = GetTransactions()
		if tc.expected {
			assert.NotEmptyf(t, transactions, "%s has produced no transactions", name)
			assert.Equal(t, tc.second.name, transactions[0].first.name, "%s has the wrong user first in the first entry", name)
			assert.Equal(t, tc.first.name, transactions[0].second.name, "%s has the wrong user second in the first entry", name)
			assert.Equal(t, tc.amount1, transactions[0].value, "%s has the wrong value in the first entry", name)
			assert.Equal(t, tc.tType1, transactions[0].tType, "%s has the wrong transaction type in the first entry", name)
			assert.Equal(t, tc.first.name, transactions[1].first.name, "%s has the wrong user first in the second entry", name)
			assert.Equal(t, tc.second.name, transactions[1].second.name, "%s has the wrong user second in the second entry", name)
			assert.Equal(t, tc.amount2, transactions[1].value, "%s has the wrong value in the second entry", name)
			assert.Equal(t, tc.tType2, transactions[1].tType, "%s has the wrong transaction type in the second entry", name)
		} else {
			assert.Emptyf(t, transactions, "%s has produced transactions when none were expected", name)

		}
	}
}
